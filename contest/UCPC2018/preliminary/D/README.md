# 나무탈출

## 설명

```
1에서 N번까지 노드를 갖는 트리가 주어짐.
1번 정점은 루트, 자식이 없으면 리프.

그 트리가 게임판인데, 처음엔 모든 리프에 말이 있음.
각 턴마다 말을 부모 노드로 옮김.
루트에 도착하면 말 제거.
마지막으로 말이 없어서 이동하지 못하는 사람이 짐.

게임의 선을 받았을 때, 이길 수 있을지 판독.
```

정점 개수 n은 2에서 50만개다.
`a b`로 트리의 간선 정보가 n줄 주어진다.
a와 b는 같을 수 없고, 1보다 크거나 같고 n보다 작거나 같다.

2초만에 풀어야하며, 메모리 제한은 512MB.

일단 예제를 그려보고 선을 잡았을 때 승리 조건만
파악해서 게임을 ㄹㅇ 시뮬레이션 안돌려도 되는 문제면 좋겠다.

아마도? 말이 있는 곳에서 루트까지 홀수 높이의 말이 홀수 개 있으면 승리하는 듯하다. 만약 짝수 높이만 있으면 무조건 지고, 홀짝을 갖는 여러 높이가 있으면 짝수는 무시해도 될 것 같다.

하... 그러면
나무를 그리는데... 막상 어케 그릴지 안떠오르니까
무슨 정보만 필요할지 생각을 해보면...

문제 속에서 이게 암만 생각해도 트리 쉑인데,
정점 개수 n이 주어지면 밑에 간선 정보에는 무적권
누군가 연결이 되어서 루트까지 닿는 칭구들이 아닐까?
그러니까 연결 안되는 노드는 절대 없다고 생각해도 무방하다고 접근해보자.

그러면 1~n번 노드까지 이걸 어케그리냐면
아.......... 그래프 그리듯이 해도되나?
인접행렬로는 하지말고, 인접리스트로 구현하는데,
1번이랑 이어진 쉑들을 쥰내 붙이고, 머
그렇게 하는데 간선을 받으면 양쪽 노드에 중복으로 붙인다.
음. 아무튼 이 야랄?을 다하고나면 이건 이상해보이지만 트리다!

그린 다음에는 이러면 안될까?
루트에서 리프까지 닿도록 BFS(1)을 돌린다.
그러다 리프를 만나면 해당 노드까지 내려간 거리가 홀짝인지 파악되고 홀이면 개수를 증가시킨다.
